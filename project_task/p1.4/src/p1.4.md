## 1) Example Case --- Bank 

### Performance Variables Interpretation

-   **A (arrivals count):** incremented when a customer enters the bank
    and joins a queue.
-   **C (completed count):** incremented when a customer finishes
    service at a teller/advisor.
-   **B (busy time):** cumulative time that a teller/advisor is serving
    customers.
-   **T (total time):** simulation clock / branch open time.
-   **U (utilization = B/T):** fraction of time a teller/advisor is
    busy.
-   **X (throughput = C/T):** customers served per unit time.
-   **S (service time = B/C):** average service duration per customer at
    that service point.
-   **Rᵢ (response time of customer i):** time from arrival in queue to
    end of service.
-   **W (sum of all response times):** cumulative sum of Rᵢ values.
-   **R (average response time = W/C):** average waiting+service time
    experienced by a customer.
-   **N (average number in system = W/T):** time-average number of
    customers at the service point.

## 2) Categories of Maintaining / Updating Measures

**Per-service-point counters:** - A_sp, C_sp, B_sp, W_sp (maintained at
arrivals, service completions, and time accruals).

**Per-customer records:** - Arrival time, service start, service end →
used to compute Rᵢ.

**System-wide totals:** - Aggregates across service points (A_total,
C_total, W_total, B_total).

**Update triggers:** - Arrival event → update A. - Service start → mark
service start time. - Service completion → update C, W, compute Rᵢ. -
A-phase time advance → update B and N with time-weighted accumulation.

**Computation time:** - Online updates (counters, accumulators). -
End-of-run derived values (U, X, S, R, N).

## 3) Two Example Systems

### A) Small Clinic (3 service points: Registration → Nurse → Doctor)

``` mermaid
flowchart LR
    nowhere1[ ] --> buffer1[(Queue)]
    buffer1 -.- service1((Service Point))
    service1 --> buffer2[(Queue)]
    buffer2 -.- service2((Service Point))
    service2 --> buffer3[(Queue)]
    buffer3 -.- service3((Service Point))
    service3 --> nowhere2[ ]

    style nowhere1 height:0px;
    style nowhere2 height:0px;
```

### B) Airport Check-in (4 service points: Kiosk → Bag Drop → Security → Boarding)

``` mermaid
flowchart LR
    nowhere1[ ] --> buffer1[(Queue)]
    buffer1 -.- service1((Service Point))
    service1 --> buffer2[(Queue)]
    buffer2 -.- service2((Service Point))
    service2 --> buffer3[(Queue)]
    buffer3 -.- service3((Service Point))
    service3 --> buffer4[(Queue)]
    buffer4 -.- service4((Service Point))
    service4 --> nowhere2[ ]

    style nowhere1 height:0px;
    style nowhere2 height:0px;
```

## 4) Algorithm for Main Loop of Simulator (Three-phase)

``` pseudocode
while not stopCondition():
    // --- A-PHASE: advance time ---
    tNext = EventCalendar.peekNextTime()
    tNow  = Clock.now()
    Clock.advanceTo(tNext)
    delta = Clock.now() - tNow

    for sp in ServicePoints:
        if sp.isBusy():
            sp.B_sp += delta
        sp.N_accumulator += (sp.queueLength() + sp.inServiceCount()) * delta

    // --- B-PHASE: execute scheduled events ---
    dueEvents = EventCalendar.popAllAt(Clock.now())
    for e in dueEvents:
        if e is ArrivalEvent:
            sp.A_sp += 1
            customer.arrival_time = Clock.now()
            sp.enqueue(customer)
        if e is ServiceCompletionEvent:
            sp.C_sp += 1
            response = Clock.now() - customer.arrival_time
            sp.W_sp += response
            // depart or route customer

    // --- C-PHASE: conditional events ---
    repeat:
        changed = false
        for sp in ServicePoints:
            if sp.canStartService():
                cust = sp.dequeue()
                cust.service_start = Clock.now()
                serviceTime = sp.sampleService()
                EventCalendar.schedule(ServiceCompletionEvent(sp, cust),
                                       Clock.now() + serviceTime)
                changed = true
    until not changed

// End of run: compute U, X, S, R, N for each service point
```

## 5) A/B/C Phases Explained with Simulator Classes

-   **A-phase (Advance):**
    -   In `Simulator.advanceTime()`: move `Clock` to next event time.
    -   Update B (busy time) and N (queue length time integral).
    -   Classes: `Clock`, `EventCalendar`, `ServicePoint`, `Stats`.
-   **B-events (Basic scheduled events):**
    -   Subclasses of `Event`: `ArrivalEvent`, `ServiceCompletionEvent`.
    -   On arrival → update A, enqueue customer.
    -   On completion → update C, compute Rᵢ, update W.
    -   Classes: `Event`, `EventCalendar`, `ServicePoint`, `Customer`,
        `Stats`.
-   **C-events (Conditional events):**
    -   Immediate actions triggered by state.
    -   Example: if server idle and queue nonempty, start service now.
    -   Classes: `ServicePoint` (with `canStartService`,
        `startService`), `EventCalendar`.